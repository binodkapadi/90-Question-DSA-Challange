---------------brute-force approach (O(n²)):-----------------
INPUT:
nums = [1,1,1], k = 2
Working:
i=0 → [1,1] → sum=2 → count=1
i=1 → [1,1] (the last two) → sum=2 → count=2
✅ Output = 2

SOLUTION(1ST APPROACH) ==>

class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        int n = nums.size();
        int count = 0;
        for(int i = 0; i < n; i++){
            int sum = 0;
            for (int j = i; j < n; j++) {
                sum += nums[j];
                if (sum == k)
                    count++;
            }
        }
        return count;    
    }
};

-----------------------------------------------------------------------
++++++++++++ Subarray Sum Equals K using prefix sum + hashmap (O(n) time complexity): +++++++++++++++
INPUT:
nums = [1,1,1], k = 2

prefixSum:  [1,2,3]
count map:
{0:1}
→ currentSum=1 → not found (1-2=-1) → map={0:1,1:1}
→ currentSum=2 → found (2-2=0) → count+=1 → map={0:1,1:1,2:1}
→ currentSum=3 → found (3-2=1) → count+=1 → map={0:1,1:1,2:1,3:1}

Total count = 2

SOLUTION(2ND APPROACH) ==>

class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        unordered_map<int, int> prefixSumCount;
        prefixSumCount[0] = 1;  // base case: sum 0 occurs once
        int currentSum = 0, count = 0;

        for (int num : nums) {
            currentSum += num;
        
        // Check if there exists a prefix sum such that currentSum - prefixSum = k
        if (prefixSumCount.find(currentSum - k) != prefixSumCount.end()) {
            count += prefixSumCount[currentSum - k];
        }

        // Update count of current prefix sum
        prefixSumCount[currentSum]++;
    }

    return count;  
    }
};
